# 数据结构与算法

## 数据结构定义

- “数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。” --- 《数据结构、算法与应用》

- “数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以 带来最优效率的算法。” ---中文维基百科

- “数据结构是ADT（抽象数据类型 Abstract Data Type）的物理实现。” --- 《数据结构与算法分析》

  ADT: Abstract Data Type，**抽象数据类型**，我们在组合已有的数据结构来实现一种新的数据类型， ADT 定义了类型的数据和操作。

## 算法定义

- 一个有限指令集, 每条指令的描述不依赖于语言
- 接受一些输入（有些情况下不需要输入）
- 产生输出
- 一定在有限步骤之后终止

## 栈

### 1.栈的特性

```python
栈（stack），它是一种运算受限的线性表,后进先出(LIFO)

- LIFO(last in first out)表示就是后进入的元素, 第一个弹出栈空间. 类似于自动餐托盘, 最后放上的托盘, 往往先把拿出去使用.

- 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。

- 向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；

- 从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
```

### 2.栈的常见操作

```
- `push(element)`:  添加一个新元素到栈顶位置.

- `pop()`：移除栈顶的元素，同时返回被移除的元素。

- `peek()`：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。

- `isEmpty()`：如果栈里没有任何元素就返回`true`，否则返回`false`。

- `clear()`：移除栈里的所有元素。

- `size()`：返回栈里的元素个数。这个方法和数组的`length`属性很类似。
```

### 3.代码实现栈的操作

```python
class Stack:
    def __init__(self):  # list列表来作为栈使用
        self.__list = []

    def push(self, data):
        self.__list.append(data)

    def pop(self):
        if not self.is_empty():
            return self.__list.pop()
        else:
            return '这是一个空栈'

    def peek(self):
        if not self.is_empty():
            return self.__list[-1]
        else:
            return '这是一个空栈'

    def is_empty(self):
        return self.__list == []

    def size(self):
        return len(self.__list)


if __name__=='__main__':
    s=Stack()
    s.push(1)
    s.push(2)
    s.push(3)
    s.push(4)
    print(s.size())
    print(s.peek())
    print(s.pop())
    print(s.size())
```



## 队列

### 1.队列的特性

```python
队列(Queue)，它是一种运算受限的线性表,先进先出(FIFO First In First Out)

- 队列是一种受限的线性结构

- 受限之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作
```

### 2.队列的常见操作

```python
- `enqueue(element)`：向队列尾部添加一个（或多个）新的项。

- `dequeue()`：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。

- `front()`：返回当前队列中第一个元素，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与`Stack`类的`peek`方法非常类似）。

- `isEmpty()`：如果队列中不包含任何元素，返回`true`，否则返回`false`。

- `size()`：返回队列包含的元素个数，与数组的`length`属性类似.
```

### 3.代码实现普通队列

```python
class Queue:
    def __init__(self):
        self.__queue = []

    def enqueue(self, data):
        self.__queue.append(data)

    def dequeue(self):
        if self.is_empty():
            print('队列是空的！')
        else:
            return self.__queue.pop(0)

    def front(self):
        if self.is_empty():
            print('队列是空的！')
        else:
            return self.__queue[0]

    def is_empty(self):
        return self.__queue == []

    def size(self):
        return len(self.__queue)

if __name__=='__main__':
    q=Queue()
    q.enqueue(1)
    q.enqueue(2)
    q.enqueue(32)
    print(q.size())
    print(q.dequeue())
    print(q.front())
```

### 4.优先队列特性

```python
  - 我们知道, 普通的队列插入一个元素, 数据会被放在后端. 并且需要前面所有的元素都处理完成后才会处理前面的数据.
  
  - 但是优先级队列, 在插入一个元素的时候会考虑该数据的优先级.(和其他数据优先级进行比较)
  
  - 比较完成后, 可以得出这个元素正确的队列中的位置. 其他处理方式, 和队列的处理方式一样.
  
  - 也就是说, 如果我们要实现优先级队列, 最主要是要修改添加方法. (当然, 还需要以某种方式来保存元素的优先级)
```

### 5.代码实现优先队列

```python
class Node:
    def __init__(self,data,rank):
        self.data=data
        self.rank=rank

    def __str__(self):
        return f'数据：{self.data},优先级：{self.rank}'

class first_Queue:
    def __init__(self):
        self.__queue=[]

    def enqueue(self,data,rank):
        node=Node(data,rank)
        if self.is_empty():
            self.__queue.append(node)
        else:
            flag=True
            for i in range(len(self.__queue)):
                if self.__queue[i].rank>node.rank:
                    self.__queue.insert(i,node)
                    flag=False
                    break
            if flag:
                self.__queue.append(node)
    def dequeue(self):
        if self.is_empty():
            print('队列是空的！')
        else:
            return self.__queue.pop(0)


    def front(self):
        if self.is_empty():
            print('队列是空的！')
        else:
            return self.__queue[0]

    def is_empty(self):
        return self.__queue == []

    def size(self):
        return len(self.__queue)

    def get_all_data(self):
        for i in self.__queue:
            print(i)

if __name__=='__main__':
    q=first_Queue()
    q.enqueue(1,1)
    q.enqueue(2,1)
    q.enqueue(32,2)
    q.enqueue(11,3)
    q.enqueue(322,3)
    q.enqueue(3333,1)
    q.enqueue(444,6)
    q.enqueue(11000,0)
    q.get_all_data()
```



## 链表

### 1.链表的特性

```python
链表是链式的存储多个元素.

- 但不同于列表, 链表中的元素在内存中不必是连续的空间

- 链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针或者链接)组成

- 链表访问任何一个位置的元素时, 都需要从头开始访问.(无法跳过第一个元素访问任何一个元素)
```

### 2.链表的常见操作

```python
- `append(element)`：向列表尾部添加一个新的项

- `insert(position, element)`：向列表的特定位置插入一个新的项。

- `remove(element)`：从列表中移除一项。

- `indexOf(element)`：返回元素在链表中的索引。如果列表中没有该元素则返回`-1`。

- `removeAt(position)`：从列表的特定位置移除一项。

- `isEmpty()`：如果链表中不包含任何元素，返回`true`，如果链表长度大于0则返回`false`。

- `size()`：返回链表包含的元素个数。与数组的`length`属性类似。
```

### 3.代码实现单向列表

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkList:

    def __init__(self):
        self.__head = None

    def head_append(self, data):##头插法
        node = Node(data)
        node.next = self.__head
        self.__head = node

    def tail_append(self, data):#尾插法
        node = Node(data)
        if self.is_empty():
            self.__head = node
        else:
            tail = self.__head
            while (tail.next!= None):
                tail = tail.next
            tail.next = node

    def insert(self, index, data):
        if index > self.size():
            self.tail_append(data)
        elif index <= 0:
            self.head_append(data)
        else:
            node = Node(data)
            pos = 0
            item = self.__head
            while (pos < (index - 1)):
                item = item.next
                pos += 1
            node.next = item.next
            item.next = node

    def indexof(self, data):
        item = self.__head
        for i in range(self.size()):
            if item.data == data:
                return i
            item = item.next
        return -1

    def removeAt(self, index):
        if index < 0 or index > self.size() - 1:
            print('坐标越界！')
        else:
            if index==0:
                self.__head=self.__head.next
            else:
                current = self.__head
                pre = None
                pos = 0
                while (pos < index):
                    pre = current
                    current = current.next
                    pos+=1
                pre.next = current.next

    def remove(self, data):
        index = self.indexof(data)
        self.removeAt(index)

    def is_empty(self):
        return self.__head == None

    def size(self):
        count = 0
        all = self.__head
        while (all!= None):
            all = all.next
            count += 1
        return count

    def get_all_data(self):
        current = self.__head
        while (current != None):
            print(current.data)
            current = current.next


if __name__ == '__main__':
    ll = LinkList()
    # ll.head_append(1)
    # ll.head_append(2)
    # ll.head_append(3)
    ll.tail_append(11)
    ll.tail_append(22)
    ll.tail_append(33)
    # ll.insert(2,55)
    ll.get_all_data()
    #ll.removeAt(0)
    ll.remove(11)
    ll.get_all_data()
   # print(ll.indexof(3))
```


